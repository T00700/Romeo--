name: Mirror Release Assets

on:
  schedule:
    - cron: '0,30 * * * *'
  workflow_dispatch:

jobs:
  Downloading_Assets:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    services:
      docker:
        image: xream/script-hub:latest
        ports:
          - 9100:9100
          - 9101:9101
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Git
        run: |
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"

      # 优化点1: 移除 apt-get，ubuntu-latest 已预装必要工具
      
      - name: Wait for Docker services to be ready
        run: |
          echo "Waiting for Docker services to be ready..."
          # 优化点2: 使用 timeout 和更短的间隔
          timeout 60 bash -c 'until nc -z localhost 9100 && nc -z localhost 9101; do sleep 1; done'

      - name: Download assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 初始化变量
          touch No_link_provided_for_srmodule.txt
          
          # 预先创建所有可能的目录，避免循环中重复创建
          mkdir -p Modules/Surge/{NSRingo,BiliUniverse,DualSubs,VirgilClyne} \
                   Modules/Loon/{NSRingo,BiliUniverse,DualSubs,VirgilClyne} \
                   Modules/Shadowrocket/{NSRingo,BiliUniverse,DualSubs}

          # === 处理 VirgilClyne (使用 Git Clone 替代 API 遍历) ===
          echo "Processing repository: VirgilClyne/GetSomeFries"
          git clone --depth 1 https://github.com/VirgilClyne/GetSomeFries.git temp_virgil
          
          # 1. 处理 sgmodule
          if [ -d "temp_virgil/sgmodule" ]; then
            cp temp_virgil/sgmodule/*.sgmodule Modules/Surge/VirgilClyne/
            # 记录 URL 用于后续转换，保持原逻辑
            for f in temp_virgil/sgmodule/*.sgmodule; do
              filename=$(basename "$f")
              echo "https://raw.githubusercontent.com/VirgilClyne/GetSomeFries/main/sgmodule/$filename" >> No_link_provided_for_srmodule.txt
            done
          fi
          
          # 2. 处理 plugin (重命名为 .lpx)
          if [ -d "temp_virgil/plugin" ]; then
            for f in temp_virgil/plugin/*.plugin; do
              filename=$(basename "$f" .plugin)
              cp "$f" "Modules/Loon/VirgilClyne/${filename}.lpx"
            done
          fi
          rm -rf temp_virgil

          # === 处理 Release 仓库 ===
          REPOS=(
            "NSRingo/WeatherKit" "NSRingo/Maps" "NSRingo/LocationService" "NSRingo/Siri" "NSRingo/TV" "NSRingo/News" "NSRingo/Testflight"
            "BiliUniverse/Enhanced" "BiliUniverse/Global" "BiliUniverse/Redirect" "BiliUniverse/ADBlock" "BiliUniverse/Roaming"
            "DualSubs/Universal" "DualSubs/YouTube" "DualSubs/Spotify" "DualSubs/Netflix" "DualSubs/AddOn"
          )

          for REPO in "${REPOS[@]}"; do
            echo "Processing repository: $REPO"
            
            # 获取 Release 信息
            RELEASE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/releases/latest")
            
            # 简单校验
            if [ -z "$RELEASE" ] || [ "$RELEASE" == "null" ] || [[ "$(echo "$RELEASE" | jq -r '.message')" == "Not Found" ]]; then
              echo "Release not found for $REPO, skipping."
              continue
            fi

            # 提取 Assets 并在后台并发下载
            echo "$RELEASE" | jq -c '.assets[]' | while IFS= read -r ASSET; do
              ASSET_NAME=$(echo "$ASSET" | jq -r '.name')
              ASSET_URL=$(echo "$ASSET" | jq -r '.url')
              # Browser download url 用于后续记录
              ASSET_BROWSER_URL=$(echo "$ASSET" | jq -r '.browser_download_url')
              
              EXTENSION="${ASSET_NAME##*.}"
              OUTPUT_DIR=""
              SAVE_NAME="$ASSET_NAME"

              # 确定目录和文件名逻辑 (保持原逻辑)
              if [[ "$REPO" == "NSRingo"* ]]; then
                BASE_DIR="NSRingo"
              elif [[ "$REPO" == "BiliUniverse"* ]]; then
                BASE_DIR="BiliUniverse"
              elif [[ "$REPO" == "DualSubs"* ]]; then
                BASE_DIR="DualSubs"
              fi

              if [ "$EXTENSION" == "sgmodule" ]; then
                OUTPUT_DIR="./Modules/Surge/$BASE_DIR"
                # 检查是否存在对应的 srmodule
                CORRESPONDING_SRMODULE=$(echo "$RELEASE" | jq -r --arg name "$ASSET_NAME" '.assets[] | select(.name == ($name | sub(".sgmodule"; ".srmodule"))) | .browser_download_url')
                if [ -z "$CORRESPONDING_SRMODULE" ]; then
                  echo "$ASSET_BROWSER_URL" >> No_link_provided_for_srmodule.txt
                fi
              elif [ "$EXTENSION" == "plugin" ]; then
                OUTPUT_DIR="./Modules/Loon/$BASE_DIR"
                SAVE_NAME="${ASSET_NAME%.plugin}.lpx"
              elif [ "$EXTENSION" == "srmodule" ]; then
                OUTPUT_DIR="./Modules/Shadowrocket/$BASE_DIR"
              fi

              # 执行下载
              if [ -n "$OUTPUT_DIR" ]; then
                echo "Downloading $SAVE_NAME to $OUTPUT_DIR..."
                curl -sL -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/octet-stream" "$ASSET_URL" -o "$OUTPUT_DIR/$SAVE_NAME" &
              fi
            done
            # 每个 Repo 处理完等待一下，避免瞬间并发过高（可选，通常 GitHub Actions 扛得住）
            wait 
          done
          
          # 确保所有下载任务完成
          wait

      - name: Handling unprovided srmodule modules (Parallelized)
        run: |
          category="Jacob"
          encoded_category=$(echo "$category" | jq -sRr @uri)
          
          if [ -f No_link_provided_for_srmodule.txt ]; then
            while read -r module_link; do
              [ -z "$module_link" ] && continue
              
              author=$(echo "$module_link" | cut -d'/' -f4)
              filename_noext=$(basename "$module_link" | sed 's/\(.*\)\..*/\1/')
              encoded_filename=$(echo "$filename_noext" | jq -sRr @uri)

              Shadowrocket_url="http://localhost:9100/file/_start_/${module_link}/_end_/${encoded_filename}.sgmodule?type=surge-module&target=shadowrocket-module&category=${encoded_category}&nore=true"

              mkdir -p Modules/Shadowrocket/$author
              echo "Converting $filename_noext..."
              
              # 优化点3: 并发转换
              curl -sL -A "Surge Mac/2985" -o "Modules/Shadowrocket/$author/$filename_noext.srmodule" "$Shadowrocket_url" &
            done < No_link_provided_for_srmodule.txt
            
            wait
          fi

      - name: Find and replace external JS resources
        continue-on-error: true
        run: |
          js_base_url="https://github.com/${GITHUB_REPOSITORY}/raw/main/Modules/JS"
          mkdir -p Modules/JS/{NSRingo,BiliUniverse,DualSubs,VirgilClyne}

          # 优化点4: 优化查找和替换逻辑
          find Modules/Surge -type f -name "*.sgmodule" -not -path "*/Beta/*" | while read sgmodule_file; do
            author=$(dirname "$sgmodule_file" | sed 's|^Modules/Surge/||')
            module_folder=$(basename "$sgmodule_file" .sgmodule)

            js_links=$(grep -v '#' "$sgmodule_file" | grep -oP 'https?://[^ ]+\.(json|js)' || echo "")

            if [ -z "$js_links" ]; then continue; fi

            for js_link in $js_links; do
              js_filename=$(basename "$js_link")
              local_js_path="Modules/JS/$author/$module_folder/$js_filename"
              github_js_url="$js_base_url/${author}/$module_folder/$js_filename"
              
              mkdir -p "$(dirname "$local_js_path")"
              curl -sL -A "Surge Mac/2985" -o "$local_js_path" "$js_link"

              # 批量替换所有格式
              escaped_link=$(printf '%s' "$js_link" | sed 's/[.[\*^$(){}+?|]/\\&/g')
              
              # 查找同名的其他格式文件并替换
              loon_file="Modules/Loon/$author/$module_folder.lpx"
              shadowrocket_file="Modules/Shadowrocket/$author/$module_folder.srmodule"
              
              sed -i "s|$escaped_link|$github_js_url|g" "$sgmodule_file"
              [ -f "$loon_file" ] && sed -i "s|$escaped_link|$github_js_url|g" "$loon_file"
              [ -f "$shadowrocket_file" ] && sed -i "s|$escaped_link|$github_js_url|g" "$shadowrocket_file"
            done
          done

      - name: Modify sgmodule files after sync
        run: |
          find Modules/Surge -type f -name "*.sgmodule" -not -path "*/Beta/*" -exec sed -i 's/,pre-matching//g' {} +

      - name: Commit and push changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DATE="$(TZ='Asia/Shanghai' date '+%Y-%m-%d %H:%M:%S')"
          git add Modules/*
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            COMMIT_MESSAGE="Synched assets at $DATE (UTC+8)"
            git stash
            git pull --rebase
            git stash pop || true # 防止 stash pop 失败导致 action 停止
            git add Modules/*
            git commit -m "$COMMIT_MESSAGE"
            git push
          fi
